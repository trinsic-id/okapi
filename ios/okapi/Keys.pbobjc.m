// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: keys.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "Keys.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective C Class declarations
// Forward declarations of Objective C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(GPBStruct);
GPBObjCClassDeclaration(JsonWebKey);

#pragma mark - KeysRoot

@implementation KeysRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - KeysRoot_FileDescriptor

static GPBFileDescriptor *KeysRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"okapi.keys"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum KeyType

GPBEnumDescriptor *KeyType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Ed25519\000X25519\000P256\000Bls12381G1G2\000Secp256"
        "K1\000";
    static const int32_t values[] = {
        KeyType_Ed25519,
        KeyType_X25519,
        KeyType_P256,
        KeyType_Bls12381G1G2,
        KeyType_Secp256K1,
    };
    static const char *extraTextFormatInfo = "\003\000\007\000\003\014\000\004\007\"\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(KeyType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:KeyType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL KeyType_IsValidValue(int32_t value__) {
  switch (value__) {
    case KeyType_Ed25519:
    case KeyType_X25519:
    case KeyType_P256:
    case KeyType_Bls12381G1G2:
    case KeyType_Secp256K1:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - GenerateKeyRequest

@implementation GenerateKeyRequest

@dynamic seed;
@dynamic keyType;

typedef struct GenerateKeyRequest__storage_ {
  uint32_t _has_storage_[1];
  KeyType keyType;
  NSData *seed;
} GenerateKeyRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "seed",
        .dataTypeSpecific.clazz = Nil,
        .number = GenerateKeyRequest_FieldNumber_Seed,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GenerateKeyRequest__storage_, seed),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "keyType",
        .dataTypeSpecific.enumDescFunc = KeyType_EnumDescriptor,
        .number = GenerateKeyRequest_FieldNumber_KeyType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GenerateKeyRequest__storage_, keyType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GenerateKeyRequest class]
                                     rootClass:[KeysRoot class]
                                          file:KeysRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GenerateKeyRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t GenerateKeyRequest_KeyType_RawValue(GenerateKeyRequest *message) {
  GPBDescriptor *descriptor = [GenerateKeyRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GenerateKeyRequest_FieldNumber_KeyType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetGenerateKeyRequest_KeyType_RawValue(GenerateKeyRequest *message, int32_t value) {
  GPBDescriptor *descriptor = [GenerateKeyRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GenerateKeyRequest_FieldNumber_KeyType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - GenerateKeyResponse

@implementation GenerateKeyResponse

@dynamic keyArray, keyArray_Count;
@dynamic hasDidDocument, didDocument;

typedef struct GenerateKeyResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *keyArray;
  GPBStruct *didDocument;
} GenerateKeyResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "keyArray",
        .dataTypeSpecific.clazz = GPBObjCClass(JsonWebKey),
        .number = GenerateKeyResponse_FieldNumber_KeyArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GenerateKeyResponse__storage_, keyArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "didDocument",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStruct),
        .number = GenerateKeyResponse_FieldNumber_DidDocument,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GenerateKeyResponse__storage_, didDocument),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GenerateKeyResponse class]
                                     rootClass:[KeysRoot class]
                                          file:KeysRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GenerateKeyResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResolveRequest

@implementation ResolveRequest

@dynamic did;

typedef struct ResolveRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *did;
} ResolveRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "did",
        .dataTypeSpecific.clazz = Nil,
        .number = ResolveRequest_FieldNumber_Did,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResolveRequest__storage_, did),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResolveRequest class]
                                     rootClass:[KeysRoot class]
                                          file:KeysRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResolveRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResolveResponse

@implementation ResolveResponse

@dynamic hasDidDocument, didDocument;
@dynamic keysArray, keysArray_Count;

typedef struct ResolveResponse__storage_ {
  uint32_t _has_storage_[1];
  GPBStruct *didDocument;
  NSMutableArray *keysArray;
} ResolveResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "didDocument",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStruct),
        .number = ResolveResponse_FieldNumber_DidDocument,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResolveResponse__storage_, didDocument),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "keysArray",
        .dataTypeSpecific.clazz = GPBObjCClass(JsonWebKey),
        .number = ResolveResponse_FieldNumber_KeysArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ResolveResponse__storage_, keysArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResolveResponse class]
                                     rootClass:[KeysRoot class]
                                          file:KeysRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResolveResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - JsonWebKey

@implementation JsonWebKey

@dynamic kid;
@dynamic x;
@dynamic y;
@dynamic d;
@dynamic crv;
@dynamic kty;

typedef struct JsonWebKey__storage_ {
  uint32_t _has_storage_[1];
  NSString *kid;
  NSString *x;
  NSString *y;
  NSString *d;
  NSString *crv;
  NSString *kty;
} JsonWebKey__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "kid",
        .dataTypeSpecific.clazz = Nil,
        .number = JsonWebKey_FieldNumber_Kid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(JsonWebKey__storage_, kid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "x",
        .dataTypeSpecific.clazz = Nil,
        .number = JsonWebKey_FieldNumber_X,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(JsonWebKey__storage_, x),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "y",
        .dataTypeSpecific.clazz = Nil,
        .number = JsonWebKey_FieldNumber_Y,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(JsonWebKey__storage_, y),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "d",
        .dataTypeSpecific.clazz = Nil,
        .number = JsonWebKey_FieldNumber_D,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(JsonWebKey__storage_, d),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "crv",
        .dataTypeSpecific.clazz = Nil,
        .number = JsonWebKey_FieldNumber_Crv,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(JsonWebKey__storage_, crv),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "kty",
        .dataTypeSpecific.clazz = Nil,
        .number = JsonWebKey_FieldNumber_Kty,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(JsonWebKey__storage_, kty),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[JsonWebKey class]
                                     rootClass:[KeysRoot class]
                                          file:KeysRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(JsonWebKey__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
