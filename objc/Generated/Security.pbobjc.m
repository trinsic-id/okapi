// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: security.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "Security.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective C Class declarations
// Forward declarations of Objective C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(EncryptionHeader);
GPBObjCClassDeclaration(EncryptionRecipient);
GPBObjCClassDeclaration(Signature);

#pragma mark - SecurityRoot

@implementation SecurityRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - SecurityRoot_FileDescriptor

static GPBFileDescriptor *SecurityRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"didcomm.messaging"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum EncryptionMode

GPBEnumDescriptor *EncryptionMode_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Direct\000ContentEncryptionKey\000";
    static const int32_t values[] = {
        EncryptionMode_Direct,
        EncryptionMode_ContentEncryptionKey,
    };
    static const char *extraTextFormatInfo = "\002\000&\000\001\'\252\243\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(EncryptionMode)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:EncryptionMode_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL EncryptionMode_IsValidValue(int32_t value__) {
  switch (value__) {
    case EncryptionMode_Direct:
    case EncryptionMode_ContentEncryptionKey:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum EncryptionAlgorithm

GPBEnumDescriptor *EncryptionAlgorithm_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Xchacha20Poly1305\000AesGcm\000";
    static const int32_t values[] = {
        EncryptionAlgorithm_Xchacha20Poly1305,
        EncryptionAlgorithm_AesGcm,
    };
    static const char *extraTextFormatInfo = "\002\000)(\000\001#\243\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(EncryptionAlgorithm)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:EncryptionAlgorithm_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL EncryptionAlgorithm_IsValidValue(int32_t value__) {
  switch (value__) {
    case EncryptionAlgorithm_Xchacha20Poly1305:
    case EncryptionAlgorithm_AesGcm:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - SignedMessage

@implementation SignedMessage

@dynamic payload;
@dynamic signaturesArray, signaturesArray_Count;

typedef struct SignedMessage__storage_ {
  uint32_t _has_storage_[1];
  NSData *payload;
  NSMutableArray *signaturesArray;
} SignedMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "payload",
        .dataTypeSpecific.clazz = Nil,
        .number = SignedMessage_FieldNumber_Payload,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SignedMessage__storage_, payload),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "signaturesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Signature),
        .number = SignedMessage_FieldNumber_SignaturesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SignedMessage__storage_, signaturesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SignedMessage class]
                                     rootClass:[SecurityRoot class]
                                          file:SecurityRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SignedMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Signature

@implementation Signature

@dynamic header;
@dynamic signature;

typedef struct Signature__storage_ {
  uint32_t _has_storage_[1];
  NSData *header;
  NSData *signature;
} Signature__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "header",
        .dataTypeSpecific.clazz = Nil,
        .number = Signature_FieldNumber_Header,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Signature__storage_, header),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "signature",
        .dataTypeSpecific.clazz = Nil,
        .number = Signature_FieldNumber_Signature,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Signature__storage_, signature),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Signature class]
                                     rootClass:[SecurityRoot class]
                                          file:SecurityRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Signature__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SignatureHeader

@implementation SignatureHeader

@dynamic algorithm;
@dynamic keyId;

typedef struct SignatureHeader__storage_ {
  uint32_t _has_storage_[1];
  NSString *algorithm;
  NSString *keyId;
} SignatureHeader__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "algorithm",
        .dataTypeSpecific.clazz = Nil,
        .number = SignatureHeader_FieldNumber_Algorithm,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SignatureHeader__storage_, algorithm),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "keyId",
        .dataTypeSpecific.clazz = Nil,
        .number = SignatureHeader_FieldNumber_KeyId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SignatureHeader__storage_, keyId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SignatureHeader class]
                                     rootClass:[SecurityRoot class]
                                          file:SecurityRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SignatureHeader__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EncryptedMessage

@implementation EncryptedMessage

@dynamic iv;
@dynamic aad;
@dynamic ciphertext;
@dynamic tag;
@dynamic recipientsArray, recipientsArray_Count;

typedef struct EncryptedMessage__storage_ {
  uint32_t _has_storage_[1];
  NSData *iv;
  NSData *aad;
  NSData *ciphertext;
  NSData *tag;
  NSMutableArray *recipientsArray;
} EncryptedMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "iv",
        .dataTypeSpecific.clazz = Nil,
        .number = EncryptedMessage_FieldNumber_Iv,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EncryptedMessage__storage_, iv),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "aad",
        .dataTypeSpecific.clazz = Nil,
        .number = EncryptedMessage_FieldNumber_Aad,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(EncryptedMessage__storage_, aad),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "ciphertext",
        .dataTypeSpecific.clazz = Nil,
        .number = EncryptedMessage_FieldNumber_Ciphertext,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(EncryptedMessage__storage_, ciphertext),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "tag",
        .dataTypeSpecific.clazz = Nil,
        .number = EncryptedMessage_FieldNumber_Tag,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(EncryptedMessage__storage_, tag),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "recipientsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(EncryptionRecipient),
        .number = EncryptedMessage_FieldNumber_RecipientsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(EncryptedMessage__storage_, recipientsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EncryptedMessage class]
                                     rootClass:[SecurityRoot class]
                                          file:SecurityRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EncryptedMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EncryptionHeader

@implementation EncryptionHeader

@dynamic mode;
@dynamic algorithm;
@dynamic keyId;
@dynamic senderKeyId;

typedef struct EncryptionHeader__storage_ {
  uint32_t _has_storage_[1];
  EncryptionMode mode;
  EncryptionAlgorithm algorithm;
  NSString *keyId;
  NSString *senderKeyId;
} EncryptionHeader__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "mode",
        .dataTypeSpecific.enumDescFunc = EncryptionMode_EnumDescriptor,
        .number = EncryptionHeader_FieldNumber_Mode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EncryptionHeader__storage_, mode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "algorithm",
        .dataTypeSpecific.enumDescFunc = EncryptionAlgorithm_EnumDescriptor,
        .number = EncryptionHeader_FieldNumber_Algorithm,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(EncryptionHeader__storage_, algorithm),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "keyId",
        .dataTypeSpecific.clazz = Nil,
        .number = EncryptionHeader_FieldNumber_KeyId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(EncryptionHeader__storage_, keyId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "senderKeyId",
        .dataTypeSpecific.clazz = Nil,
        .number = EncryptionHeader_FieldNumber_SenderKeyId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(EncryptionHeader__storage_, senderKeyId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EncryptionHeader class]
                                     rootClass:[SecurityRoot class]
                                          file:SecurityRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EncryptionHeader__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t EncryptionHeader_Mode_RawValue(EncryptionHeader *message) {
  GPBDescriptor *descriptor = [EncryptionHeader descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:EncryptionHeader_FieldNumber_Mode];
  return GPBGetMessageRawEnumField(message, field);
}

void SetEncryptionHeader_Mode_RawValue(EncryptionHeader *message, int32_t value) {
  GPBDescriptor *descriptor = [EncryptionHeader descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:EncryptionHeader_FieldNumber_Mode];
  GPBSetMessageRawEnumField(message, field, value);
}

int32_t EncryptionHeader_Algorithm_RawValue(EncryptionHeader *message) {
  GPBDescriptor *descriptor = [EncryptionHeader descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:EncryptionHeader_FieldNumber_Algorithm];
  return GPBGetMessageRawEnumField(message, field);
}

void SetEncryptionHeader_Algorithm_RawValue(EncryptionHeader *message, int32_t value) {
  GPBDescriptor *descriptor = [EncryptionHeader descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:EncryptionHeader_FieldNumber_Algorithm];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - EncryptionRecipient

@implementation EncryptionRecipient

@dynamic hasHeader, header;
@dynamic contentEncryptionKey;

typedef struct EncryptionRecipient__storage_ {
  uint32_t _has_storage_[1];
  EncryptionHeader *header;
  NSData *contentEncryptionKey;
} EncryptionRecipient__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "header",
        .dataTypeSpecific.clazz = GPBObjCClass(EncryptionHeader),
        .number = EncryptionRecipient_FieldNumber_Header,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EncryptionRecipient__storage_, header),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "contentEncryptionKey",
        .dataTypeSpecific.clazz = Nil,
        .number = EncryptionRecipient_FieldNumber_ContentEncryptionKey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(EncryptionRecipient__storage_, contentEncryptionKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EncryptionRecipient class]
                                     rootClass:[SecurityRoot class]
                                          file:SecurityRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EncryptionRecipient__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
